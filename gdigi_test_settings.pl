#!/usr/bin/perl

# This script attempts to exercise all knobs and selections
# on the main gdigi gui. It doesn't yet test pedal assignment
# or the LFO's.
#
# Each setting is set to its minimum, maximum, and midpoint
# value, then the original setting is restored. Similarly,
# each combo box entry is selected and its corresponding
# settings are exercised. Then the original combo box
# entry is restored.
#
# To run this test:
# 
# 0) Build Gdigi.pm.
#
# 1) Run gdigi -p > effect_tree.out to create a file containing
#    a description of your device's effect tree.
#
# 2) Start gdigi in its normal mode.
#
# 3) Run 'gdigi_test.pl effect_tree.out'.
#
# 4) If running from a location other than the build directory,
#    either install Gdigi.pm or adjust 'use lib'.
#
# On my RP355, the test completes in less than eight minutes after
# executing 1600+ test cases.

# Pick up the module and associated .so from the build directory.
use Gdigi qw(
        gdigi_init
        gdigi_get_parameter
        gdigi_set_parameter
);

# For sub-second sleep.
use Time::HiRes qw(usleep);

$Usage = "gdigi_test.pl <config file>
<config file> is the effect tree file generated by gdigi -p.\n";

$config_file = shift or die($Usage);

open(CONFIG, "<$config_file") or die("Failed to open $config_file: $!\n");

my $Device = <CONFIG>;
chomp $Device;
$Device =~ s/Device name: //;
print STDOUT "Device: $Device\n";

# Parse the text description of the effect tree into something
# we can easily walk.
#
# 'nodes' are references to anonymous hashes.
# 'parent' is a hash reference to the parent.
# 'children' is a reference to an array of hash references.
# 'type' is one of 'Effect Page|Effect List|Effect|On/Off|Group|Settings'
# Other fields are name, position, id, value, min, max.

my $Root = {'children' => [] };
my $current_node;

while (<CONFIG>) {
    chomp;
    s/^\s+//;
    if (/^Effect Page: (.*)/) {

        my $Effect_Page = $1;

        my $node = { 'type' => 'Effect Page',
                  'name' => $Effect_Page,
                  'parent' => $Root,
                  'children' => [],
                };
        push @$Root{'children'}, $node;
        $current_effect_page = $node;
        $current_effect_list = $current_effect = $current_group = undef;

    } elsif (/^Effect List: (.*)$/) {

        my $Effect_List = $1;

        my $node = { 'type' => 'Effect List',
                     'name' => $Effect_List,
                     'parent' => $current_effect_page,
                     'children' => [],
                   };
        push @$current_effect_page{'children'}, $node;
        $current_effect_list = $node;
        $current_effect = $current_group = undef;
        
    } elsif (/^Effect: (\d+) (\d+) (.*)/) {

        my $position = $1;
        my $id = $2;
        my $name = $3;

        my $node =  { 'type' => 'Effect',
                      'name' => $name,
                      'position' => $position,
                      'id'      => $id,
                      'parent' => $current_effect_list,
                      'children' => [],
                    };
        push @$current_effect_list{'children'}, $node;
        $current_effect = $node;
        $current_group = undef;

    } elsif (/^On\/Off: (\d+) (\d+)/) {

        my $position = $1;
        my $id = $2;

        my $node = { 'type' => 'On/Off',
                     'position' => $position,
                     'id' => $id,
                     'parent' => $current_effect,
                    };
        push @$current_effect{'children'}, $node;
        $current_group = undef;

    } elsif (/^Group: (-?\d+) (.*)/) {

        my $value = $1;
        my $name = $2;

        my $node = { 'type' => 'Group',
                     'name' => $name,
                     'value' => $value,
                     'parent' => $current_effect,
                     'children' => [],
                    };
        $current_group = $node;
        push @$current_effect{'children'}, $node;

    } elsif (/^Settings: (\d+) (\d+) (.*) min (\d+) max (\d+)/) {

        my $position = $1;
        my $id = $2;
        my $name = $3;
        my $min = $4;
        my $max = $5;

        my $node = { 'type' => 'Settings',
                     'name' => $name,
                     'position' => $position,
                     'id' => $id,
                     'min' => $min,
                     'max' => $max,
                     'parent' => $current_group,
                     };
        push @$current_group{'children'}, $node;

    }
}


close(CONFIG);

# Routine to print a tree node.
sub print_node ($) {
    my $node = shift;

    printf "%s type '%s' name '%s' pos %d id %d val %d min %d max %d\n",
            "    " x $depth,
            $$node{'type'}, $$node{'name'},
            $$node{'position'}, $$node{'id'}, $$node{'value'},
            $$node{'min'}, $$node{'max'};

    return;
}

# Simple tree walking function. Left here as a template.
sub walk_tree ($) {
    my $node = shift;

    print_node($node);

    $depth++;
    my $array_ref = $$node{'children'};
    foreach my $child (@$array_ref) {
        walk_tree($child);
    }
    $depth--;
}

# Actual test routines start here.

# Global for tracking depth of recursion.
my $depth;

# Print with indentation indicating depth.
sub iprint ($) {
    my $str = shift;

    print "    " x $depth . $str;
}
    

# Set a parameter, then get the parameter and assert the values match.
sub set_and_test ($$$) {
    my $id = shift;
    my $pos = shift;
    my $val = shift;

    $tests++;

    if (gdigi_set_parameter($pos, $id, $val) < 0) {
        die("Failed to set to $val\n");
    }

    # Give time for the device to reflect the setting back to the gui.
    usleep(100000);
    if ($pos == 26 and not $first_time) {
        $first_time++;

        # This is a hack. We need a little extra delay the first time
        # we test Tone Effect Level setting to ensure that the preceding
        # reset of the tone library has settled.

        sleep(2);
    }
        

    if (gdigi_get_parameter($pos, $id, $new_val) < 0) {
        die("Failed to get paramter.\n");
    }

    if ($val != $new_val) {
        die("Device value $new_val doesn't equal value $val");
    }

    return;
}

# Get the current value of a setting.
# Test the min, max, and midpoints (assuming they are unique).
# Restore the original value.
sub test_setting ($$$$$$) {
    my $name = shift;
    my $pos = shift;
    my $id = shift;
    my $min = shift;
    my $max = shift;
    my $orig_val = shift;

    my $restore;

    if ($orig_val != $min) {
        my $str = sprintf "Test min value %d\n", $min;
        iprint($str);
        set_and_test($id, $pos, $min);
        $restore = 1;
    }
    if ($orig_val != $max) {
        iprint "Test max value $max\n";
        set_and_test($id, $pos, $max);
        $restore = 1;
    }
    my $mid_val = sprintf "%d", ($min + $max)/2;
    if ($mid_val != $min and $mid_val != $max and $mid_val != $orig_val) {
        iprint "Test mid value $mid_val.\n";
        set_and_test($id, $pos, $mid_val);
        $restore = 1;
    }

    if ($restore) {
        my $str = sprintf "Restore orig value %d\n", $orig_val;
        iprint($str);
        set_and_test($id, $pos, $orig_val);
    }
}
    
# Test an on/off effect by toggling it to the other value and back.
sub test_on_off ($$$) {
    my $id = shift;
    my $pos = shift;
    my $orig_val = shift;

    my $restore;

    if ($orig_val != 0 and $orig_val != 1) {
        die("test_on_off called with invalid orig_val $orig_val\n");
    }

    my $test_val = 1 - $orig_val;

    set_and_test($id, $pos, $test_val);
    set_and_test($id, $pos, $orig_val);
}

# Restore an effect to its original value.
sub restore_effect ($$) {
    my $node = shift;
    my $val = shift;

    my $id = $$node{'id'};
    my $pos = $$node{'position'};

    if ($id == 0 and $pos == 0) {
        # Nothing to restore for the global effect.
        return;
    }

    iprint "Restoring effect id $id position $pos to value $val\n";

    if (gdigi_set_parameter($pos, $id, $val) < 0) {
        die("Failed to restore parameter id $id pos $pos\n");
    }
    # Wait a good long time for the device to settle.
    usleep(500000);
}

# The routine to recursively walk the tree and test every setting.
# Track parent state with globals for restoration.

my $current_effect_page;
my $current_effect_list;
my $current_effect;
my $current_effect_value;
my $current_group;

sub test_tree ($) {
    my $node = shift;
    
    if ($$node{'type'} eq "Effect Page") {

        if ($current_effect) {
            restore_effect($current_effect, $current_effect_value);
        }
        $current_effect_val = $current_effect = $current_group = undef;

        iprint "Effect Page $$node{'name'}\n";

        $current_effect_page = $node;
        $current_effect_list = $current_effect = $current_group = undef;

    } elsif ($$node{'type'} eq "Effect List") {

        if ($current_effect) {
            restore_effect($current_effect, $current_effect_value);
        }
        $current_effect_val = $current_effect = $current_group = undef;

        iprint "Testing effect list: $$node{'name'}\n";
        $current_effect_list = $node;

    } elsif ($$node{'type'} eq "Effect") {

        if ($current_effect) {
            restore_effect($current_effect, $current_effect_value);
        }
        $current_effect_value = @current_settings_values =
            $current_group = undef;


        $current_effect = $node;
        my $effect_val;

        my $id = $$node{'id'};
        my $pos = $$node{'position'};
        my $name = $$node{'name'};

        iprint "Testing Effect '$name' position $pos id $id \n";

        if (not ($id == 0 and $op == 0) and
            gdigi_get_parameter($pos, $id, $effect_val) < 0) {
            die("Failed to get effect value.\n");
        }
        $current_effect_value = $effect_val;

        iprint "Current effect value $current_effect_value\n";

    } elsif ($$node{'type'} eq "On/Off") {

        my $id = $$node{'id'};
        my $pos = $$node{'position'};

        iprint "Testing On/Off\n";

        if (gdigi_get_parameter($pos, $id, $orig_val) < 0) {
            die("Failed to get on/off parameter id $id pos $pos\n");
        }

        test_on_off($id, $pos, $orig_val);

    } elsif ($$node{'type'} eq "Group") {

        my $id = $$current_effect{'id'};
        my $pos = $$current_effect{'position'};
        my $val = $$node{'value'};
        my $new_val;

        iprint "Group $$node{'name'}\n";

        $current_group = $node;
        if ($val != -1) { 
            if (gdigi_set_parameter($pos, $id, $val) < 0) {
                die("Failed to set group to $$node{'value'}\n");
            }

            # Changing the group is fairly disruptive, as the device may
            # send a device notification and update the modifier list.
            # So sleep a little longer here.
            usleep(200000);
            if (gdigi_get_parameter($pos, $id, $new_val) < 0) {
                die("Failed to get group value for id $id pos $pos\n");
            }
        }
    } elsif ($$node{'type'} eq "Settings") {

        my $name = $$node{'name'};
        my $id = $$node{'id'};
        my $pos = $$node{'position'};
        my $min = $$node{'min'};
        my $max = $$node{'max'};

        my $orig_val;

        if (gdigi_get_parameter($pos, $id, $orig_val) < 0) {
            die("Failed to get parameter for setting $name position $pos id $id \n");
        }

        iprint "Testing setting $name position $pos id $id orig value $orig_val\n";

        test_setting($name, $pos, $id, $min, $max, $orig_val);
    }

    $depth++;

    # Recurse through our children.
    my $array_ref = $$node{'children'};
    foreach my $child (@$array_ref) {
        test_tree($child);
    }

    $depth--;
}

# Initialize the API and run the tests.

if (gdigi_init() < 0) {
    die("failed to init Gdigi.pm: $!");
}

# Uncomment this to see client IPC with gdigi.
#gdigi_set_debug();

$depth = 0;
test_tree($Root);

gdigi_fini();

print "Number of test cases executed: $tests.\n";
